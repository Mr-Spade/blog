---
abstract: 
date: 2020-10-10
---

# 一般难度模板复习

## Stoer-Wagner算法

求无向图全局最小割的一种算法。设一张图$(V,E)$的点集为$V$，边集为$E$。我们说集合$C$是图$(V,E)$的割，当且仅当$C\in E$且存在$V$的一个划分$S$和$T$，使得$(u,v)\in C\iff u\in S\land v\in T$，一个割的权值$w_C$就是割中边权的和。

考虑一个事实：对于任意两点$s,t\in V$，在一个割中$s,t$或在同一划分内，或在不同划分内。那么可以先考虑计算$s-t$割，再将$s,t$两点合并（$s,t$之间的边消去，连向其它点的边合并）并递归计算即可。

而Stoer-Wagner算法将告诉我们，总存在一对点$s,t$使得$s-t$最小割就是将$t$的所有边割除的情况。

考虑这样找到满足要求的$s,t$：设一个点集$V'\in V$，初始情况下$V'$为空。对于不在$V'$中的点$u$，定义其权值为$w_{V',u}=\sum_{v\in V'}w_{(u,v)}$。如果每次选择$w_u$最大的$u$加入$V'$（相同则随意），那么最后两个加入的点就是$s$和$t$（$t$为最后一个点）。

证明：只要证对于任意一种$s-t$割$C$，都有$w_C\geq w_{{V\setminus \{t\}},t}$即可。令$id_{a_k}=k$，$C_k=\{(u,v)\in C|id_u\leq k, id_v\leq k\}$，$V_k=\{a_1,a_2,\dots,a_k\}$。将所有点按照加入$V'$的顺序排成一个列$\{a_n\}$，对于任意一种$s-t$割$C$，设其对应的分划为$S,T$，我们称满足$n>1\land [a_{n-1}\in S]\neq[a_n\in S]$，即与前一个点不在一个分划内的点为活跃点，显然$t$为活跃点。对于任意一个活跃点$v$，我们证明$w_{C_{id_v}}\geq w_{V_{id_v},v}$即可。

采用归纳法，对于第一个活跃点$v$，不难发现$w_{C_{id_v}}=w_{V_{id_v},v}$，对于之后任意活跃点$v$，设其前一个活跃点为$u$，将$C_{id_v}$中的边分为三部分：$C_{id_u}$，$u,v$之间的点与$v$的连边(设这个集合为$A$)，其他边。那么有：

$$w_{V_{id_v},v}=w_{V_{id_u},v}+w_A\leq w_{V_{id_u},u}+w_A\leq w_{C_{id_u}}+w_A\leq w_{C_{id_v}}$$

于是结论成立。

## 扩展中国剩余定理

显然只需要考虑合并两个同余方程的情况：

$$x\equiv a_1(\bmod \ b_1)$$
$$x\equiv a_2(\bmod\ b_2)$$

第一个方程的通解为$x=a_1+k*b_1,k\in \mathbb{Z}$，代入第二个方程即有$a_1+k*b_1\equiv a_2(\bmod \ b_2)$，改写为$k_1*b_1+k_2*b_2=a_2-a_1$，利用扩展欧几里得求解即可。

## 回文自动机

对于一个字符串$s$，$s$的回文自动机的每个节点代表$s$的一个回文子串（内容相同的字串在同一个节点上），另有两个特殊节点奇根和偶根。后文将不严格区分节点和其对应的回文串

回文自动机的节点$p$有如下基本属性：
$1.len_p$表示$p$的长度，特别的，奇根的$len$为$-1$，偶根的$len$为$0$。
$2.fail_p$表示$p$的最长回文严格后缀，特别的，如果没有回文严格后缀，则其$fail$为偶根；偶根的$fail$为奇根，奇根的$fail$为自己。
$3.trans_{p,c}$表示$p$在前后各加上字符$c$之后形成的新回文串。特别的，如果新回文串不是$s$的子串，则$trans_{p,c}$为偶根；奇根的$trans$节点代表单个字符$c$组成的回文串，偶根的$trans$节点代表两个字符$c$组成的回文串。

先证明回文自动机的一个性质：$s$的回文自动机节点数为$O(|s|)$。
证明：对于任意的$s$，对其前缀采用数学归纳法。$s[1;0]$（空串）的回文自动机只有奇根和偶根，显然成立。
假设命题对$s[1;k]$成立，显然对于$s[1;k+1]$的回文自动机，其可能新增的节点都对应$s[1;k+1]$的回文后缀。假设其有非空的最长回文后缀$t$，那么$t$可能是回文自动机新增的节点，且其他$s[1;k+1]$的回文后缀也是$t$的回文后缀。
考虑$t$的回文后缀也是$t$的回文前缀，因此其必定出现在$s[1;k]$中，也就已经在原回文自动机上。因此回文自动机最多新增一个节点，命题对$s[1;k+1]$也成立。

下面考虑如何构造回文自动机。对于字符串$s$，先构造出$s[1;|s|-1]$的回文自动机，再在此基础上继续构造。

我们记录$s[1;|s|-1]$的最长回文后缀$last$（没有则为偶根），由之前命题的证明，我们只需考虑是否需要添加$s$的最长回文后缀。令$s$的最长回文后缀为$t$（没有则为空串），显然$t[2;|t|-1]$一定是$s[1;|s|-1]$的回文后缀，其对应节点$p$就是$last$的$fail$祖先（如果$t$为空串，定义$p$为奇根）。
那么考虑先找到$p$，只要在$fail$树上从$p=last$开始不断查找，就能按长度从大到小的顺序遍历$last$的所有回文后缀，找到第一个满足$s[|s|-len_p-1]=s[|s|]$的节点，就是满足要求的$p$。由于$fail$树的根为奇根，$len$为$-1$，因此这样的点总是可以找到的。

那么显然有$trans_{p,s[|s|]}$为$t$，如果$trans_{p,s[|s|]}$已经存在，那么无需添加新的节点，记$last$为$trans_{p,s[|s|]}$即可。
否则，令$t$的对应节点为$np$，并将$trans_{p,s[|s|]}$记为$np$。显然有$len_{np}=len_p+2$，且$trans_{np}$皆为偶根。
再考虑找到$fail_{np}$的问题。设$t$的最长回文严格后缀为$t'$，可知$t'[2;|t'|-1]$是$p$的祖先，记为$q$。从$fail_p$开始向上找到第一个满足$s[|s|-len_q-1]=s[|s|]$的节点即为所需要的$q$，于是$fail_{np}$就是$trans_{q,s[|s|]}$。最后将$last$设为$np$。

最后证明构造回文自动机的复杂度。先归纳假设所有节点在$fail$树上的深度都不超过其$trans$父亲的深度$+1$。考虑增量时在$fail$树上找$p$和$q$的过程，每次当前点的深度$-1$。而最后$fail_{np}$为$q$的$trans$孩子，因此$fail_{np}$的深度不超过$q$的深度$+1$,$np$的深度也就不超过$q$的深度$+2$。显然$np$深度不超过其$trans$父亲$p$的深度$+1$，归纳假设成立。由于深度的增量是$O(|s|)$的，向上查找$p$和$q$的总复杂度也是$O(|s|)$的。如果字符集为常数，构造回文自动机的复杂度就为$O(|s|)$。

## 图论经典问题

### 最大独立集$=n-$最小顶点覆盖

因为一个点集是独立集等价于其补集是点覆盖。

### 二分图最小点覆盖等于最大匹配

分为两部分证明：先证任意匹配$\leq$点覆盖。考虑一个匹配，对于任何一条匹配边，两端的点至少有一个在点覆盖中，且匹配边点不重复，故命题成立。

下面用最大匹配构造一个点覆盖。考虑对右半部分的每个未匹配点尝试增广，由于是最大匹配必定增广失败。将增广完毕后，左半部分访问过的匹配点和右半部分未访问的匹配点作为一个点集，先证明这个点集大小为最大匹配：由增广的特性，对于一条匹配边，在左半部分的点被访问后立即会访问右半部分的点，否则均不访问，因此命题成立。再证这是一个点覆盖：对匹配边来说是显然的，对于非匹配边，若其右半部分点被访问，则其一定被尝试增广过，故左半部分的点一定是匹配点（否则就增广成功了），于是左半部分是点集中的点；若其右半部分的点未被访问，由于每个没匹配的右半部分点都被增广过，因此这个点是匹配点，也在点集中，证毕。

证法2：二分图建成网络流，边的流量为无穷，最小割就是最小点覆盖。我又白证了一堆东西QAQ

## 一种代替（吊打？）单调队列的方法

一般难度模板复习×
一般难度模板预习√
在学弟x义x的博客中看到的，我自作主张简称它为扩展单调队列。
可以解决这样的问题：维护一个队列，并支持查询队列中的所有元素对一个运算$\oplus$的和，$\oplus$满足结合律，单次快速计算，但不一定有逆运算。**支持强制在线**（狂喜）
可以发现如果$\oplus$是数字的取$\max$，那就是单调队列板子题，但一般的运算不一定满足$\max$这样好的性质。
扩展单调队列方法如下：取一个队列中的关键位置$x$，维护所有$x$的后缀和$x+1$的前缀和，加入元素只要更新前缀和即可，也支持快速查询。
但是关键位置可能被弹出队列，此时我们重新将关键点$x$设置为右端点，并重新计算所有$x$的后缀和。注意到此时被计算后缀和的位置在下一次重设关键点时一定都被弹出了，所以只会对这一次重构产生贡献，总复杂度就是线性的。

## 拉格朗日反演

设$G(x)$是$F(x)$的复合逆，则拉格朗日反演式如下：

$$[x^n]H(G(x))=\frac{1}{n}[x^{n-1}]H'(x)\cdot(\frac{x}{F(x)})^n$$

证明：

为方便没有抽象代数基础的OIer们理解，增加一些合理的定义：

形如$F(x)\cdot x^k(k>0,[x^0]F\neq 0)$的多项式在通常意义下不可逆，但如果将$x$的指数范围从非负整数扩展到整数，我们可以认为：

$$\frac{1}{F(x)\cdot x^k}=x^{-k}\cdot F^{-1}(x)$$

同样可以定义扩展后的多项式的导数，有一个性质是$[x^{-1}]F'(x)\equiv 0$。

根据上面的定义，我们只要证明一个更简洁的式子：

$$[x^n]H(G(x))=\frac{1}{n}[x^{-1}]H'(x)\cdot F^{-n}(x)$$

考虑设$[x^i]F(x)=a_i$，$[x^i]H(G(x))=b_i$，对等式$\sum_{i\geq 0}b_iF^i(x)=H(x)$两边求导得：

$$\sum_{i\geq 0}b_iiF^{i-1}(x)F'(x)=H'(x)$$

于是有：

$$[x^{-1}]\sum_{i\geq 0}b_iiF^{i-n-1}(x)F'(x)=[x^{-1}]H'(x)F^{-n}(x)$$

又：

$$[x^{-1}]\sum_{i\geq 0}b_iiF^{i-n-1}(x)F'(x)=[x^{-1}]b_nnF^{-1}(x)F'(x)+\sum_{i\geq 0,i\neq n}[x^{-1}]b_iiF^{i-n-1}(x)F'(x)$$

$$=[x^{-1}]b_nnF^{-1}(x)F'(x)+\sum_{i\geq 0,i\neq n}[x^{-1}]b_ii\Big(\frac{F^{i-n}(x)}{i-n}\Big)'=[x^{-1}]b_nF^{-1}(x)F'(x)$$

$$=[x^{-1}]b_nnx^{-1}\frac{x}{F(x)}F'(x)=[x^0]b_nn\frac{x}{F(x)}F'(x)$$

$$=[x^0]b_nn(\frac{1}{a_1}-\frac{a_2}{a_1^2}x+\cdots)(a_1+2a_2x+\cdots)=b_nn$$

于是就证明了拉格朗日反演。